#!/usr/bin/env python                                                                         
# -*- coding: utf-8 -*- 

from __future__ import unicode_literals
import os
import argparse
from glob import glob
import unicodedata
import sys

version = sys.version_info
if version.major<=2 or (version.major==3 and version.minor<3):
  reload(sys)
  sys.setdefaultencoding('utf-8')


class PyColor:
    """ Standard IO Color Settings. """
    RED = '\033[1;31m'
    GREEN = '\033[1;32m'
    YELLOW = '\033[33m'
    BLUE = '\033[1;34m'
    PURPLE = '\033[1;35m'
    CYAN = '\033[36m'
    WHITE = '\033[37m'
    END = '\033[0m'
    BOLD = '\038[1m'
    UNDERLINE = '\033[4m'
    INVISIBLE = '\033[08m'
    REVERCE = '\033[07m'
    BACK_LIGHT_YELLOW = '\033[230m'
    BACK_BLACK = '\033[40m'
    LIGHT_CYAN = '\033[1;36m'


class Config():
    def __init__(self):
        """
        Set shared config between lsi and mkdiri.
        Read '~/.lsirc' and adapt the settings.
        """

        """ Read .lsirc """
        lsirc = []
        if os.path.exists('~/.lsirc'):
            with open('~/.lsirc') as f:
                lsirc = f.readlines()

        """ Set description_path """
        self.description_name = '.description.lsi'
        self.symbol = ';'

        """ Set Visual Setting """
        self.tag = {
                'pwd': self.symbol + 'pwd' + self.symbol,
                'pwd_current': self.symbol + 'pwd_c' + self.symbol,
                'dir': self.symbol + 'dir' + self.symbol,
                'file': self.symbol + 'file' + self.symbol,
                'description': self.symbol + 'desc' + self.symbol,
                'search': self.symbol + 'ss' + self.symbol,
                'search_end': self.symbol + 'se' + self.symbol,
                'end': self.symbol + 'end' + self.symbol,
                'end_user': self.symbol + 'e' + self.symbol,
                'underline': self.symbol + '_' + self.symbol,
                'red': self.symbol + 'r' + self.symbol,
                'red2': self.symbol + 'red' + self.symbol,
                'green': self.symbol + 'g' + self.symbol,
                'green2': self.symbol + 'green' + self.symbol,
                'blue': self.symbol + 'b' + self.symbol,
                'blue2': self.symbol + 'blue' + self.symbol,
                'purple': self.symbol + 'p' + self.symbol,
                'purple2': self.symbol + 'purple' + self.symbol,
                'white': self.symbol + 'w' + self.symbol,
                'white2': self.symbol + 'white' + self.symbol,
                'description_white': self.symbol + 'dw' + self.symbol
                }
        self.color = {
                self.tag['pwd'] : PyColor.UNDERLINE+PyColor.CYAN,
                self.tag['pwd_current'] : PyColor.LIGHT_CYAN,
                self.tag['dir'] : PyColor.UNDERLINE+PyColor.CYAN,
                self.tag['file'] : PyColor.WHITE,
                self.tag['description'] : PyColor.YELLOW,
                self.tag['search'] : PyColor.REVERCE,
                self.tag['search_end'] : PyColor.END,
                self.tag['end'] : PyColor.END,
                self.tag['underline'] : PyColor.UNDERLINE,
                self.tag['red'] : PyColor.RED,
                self.tag['red2'] : PyColor.RED,
                self.tag['green'] : PyColor.GREEN,
                self.tag['green2'] : PyColor.GREEN,
                self.tag['blue'] : PyColor.BLUE,
                self.tag['blue2'] : PyColor.BLUE,
                self.tag['purple'] : PyColor.PURPLE,
                self.tag['purple2'] : PyColor.PURPLE,
                self.tag['white'] : PyColor.WHITE,
                self.tag['white2'] : PyColor.WHITE,
                self.tag['description_white'] : PyColor.WHITE
                }
        self.color[self.tag['end_user']] = PyColor.END+self.get_color('description')
        self.indent = self.get_color('end')+'── '


    def get_color(self, color):
        return self.color[self.tag[color.lower()]]


class LsiVisualTransforms():
    def __init__(self):
        """
        Visual Transforms (for item).
        e.g. set color, set indent.
        """
        # Set Config
        self.config = Config()

    def _add_indent_to_new_line(self, item, prev_status):
        """
        Visual transform for Description.
        Add indent to new line. \n -> \n____

        Parameters
        ----------
        item : Dict
        prev_status : Boolean

        Returns
        -------
        status : Boolean
        item : Dict
        """
        if 'description' not in item.keys():
            status = 1
            return status, item
        indent_length = 3 * (item['depth']+1)
        base_name = item['path']
        description = item['description']

        blank = '\n'+';dw;│;se;' + ' '*int(indent_length + item['path_length'] + 3)
        description = description.split('\n')
        if len(description)>=2:
            if set(description[-1])==set(' ') or description[-1]=='':
                description = description[:-1]
        description = blank.join(description)
        status = 0
        item['description'] = description+';end;'
        return status, item

    def _add_color_to_path(self, item, prev_status):
        """
        Visual transform for Path.
        Add color to Path text.

        Parameters
        ----------
        item : Dict
        prev_status : Boolean

        Returns
        -------
        status : Boolean
        item : Dict
        """
        type = item['type']
        config = self.config
        if type=='Dir':
            item['path'] = config.get_color('dir') + item['path'] + config.get_color('end')
        elif type=='File':
            item['path'] = config.get_color('file') + item['path'] + config.get_color('end')
        status = 0
        return status, item

    def _tag2color(self, item, prev_status):
        """
        Visual transform for Description.
        change tag text to color code.

        Parameters
        ----------
        item : Dict
        prev_status : Boolean

        Returns
        -------
        status : Boolean
        item : Dict
        """
        config = self.config
        text = item['path']
        text = item['path'].replace(config.tag['search'], config.get_color('search'))
        text = text.replace(config.tag['search_end'], config.get_color('search_end')+config.get_color(item['type']))
        item['path'] = text
        if 'description' not in item.keys():
            status = 1
            return status, item

        description = [{'tag':config.tag['description'], 'text':item['description']}]
        for tag in set(config.tag.values())-set([';ss;', ';se;', ';dw;']):
            new_description = [[desc] for desc in description]
            for i, desc in enumerate(description):
                splited_text = desc['text'].split(tag)
                if len(splited_text)==1:
                    new_desc = [desc]
                elif len(splited_text)>1:
                    desc['text'] = splited_text[0]
                    new_desc = [desc]
                    for text in splited_text[1:]:
                        new_desc += [{'tag':tag, 'text':text}]
                new_description[i] = new_desc
            description = []
            for desc in new_description:
                description += desc
        output_description = ''
        for desc in description:
            text = desc['text'].replace(config.tag['search'], config.get_color('search'))
            text = text.replace(config.tag['description_white'], config.get_color('description_white'))
            text = text.replace(config.tag['search_end'], config.get_color('search_end')+config.color[desc['tag']])
            output_description += config.color[desc['tag']]
            output_description += text
        item['description'] = output_description
        status = 0
        return status, item

    def _select_indent_head(self, item, place):
        """
        Select indent head ├,└

        Parameters
        ----------
        item : Dict
        place : Int
            0 if item is not last of children
            1 if item is last of children

        Returns
        -------
        head : String (├ or └)
        item : Dict
        """
        if place==0:
            return '├', item
        if place==1:
            if 'description' in item.keys():
                item['description'] = item['description'].replace(self.config.get_color('description_white')+'│'+self.config.get_color('search_end'), self.config.get_color('search_end')+' ')
            return '└', item


    def _concat_item(self, item, place):
        """
        Concatenate all texts.
        Output final string like below.
        'file name / description\n
                     new line description'

        Parameters
        ----------
        item : Dict
        prev_status : Boolean

        Returns
        -------
        status : Boolean
        output : String
        """
        head, item = self._select_indent_head(item, place)
        if 'description' in item.keys():
            description = item['description']
        else:
            description = item['type']
        indent = head+'a'*3*item['depth'] + self.config.indent
        output = indent + item['path'] + ' / ' + description
        status = 0
        return status, output

    def run(self, item, condition):
        """
        This apply visual_transforms to an item.

        Parameters
        ----------
        item : Dict
        condition : Dict
        
        Returns
        -------
        status : Boolean
            0 == success
            1 == failed
        output : String
            An visualized item.
            This will be printed to the terminal.
        """
        prev_status = condition['status']
        transforms = []
        transforms += [self._add_indent_to_new_line]
        transforms += [self._tag2color]
        transforms += [self._add_color_to_path]
        for tr in transforms:
            prev_status, item = tr(item, prev_status)

        status, output = self._concat_item(item, condition['is_last'])
        return status, output


class LsiItemLoader():
    def __init__(self):
        """
        Item Loader

        Return 
        ------
        children : List[children_d, children_f]  
            children_d : List[items]
                item : Dict
                    dict.keys(default) = ['path', 'type', 'depth']
                    dict.keys(optional) = ['description', 'auth', 'children']
        """
        # Set Config
        self.config = Config()

    def _get_children(self, dir, show_all=False, get_only_directories=False, get_only_files=False):
        """
        Get children files and directories of the directory.

        Parameters
        ----------
        dir : String
            Directory Path
        show_all : Boolean (Optional)
            True -> Get all files and directories.

        Returns
        -------
        status : Int
            0 == success
            1 == error
        children : List [children_d, children_f]
            children_d : List[String]
                children (directories)
            children_f : List[String]
                children (files)
        """
        # Get children
        pathes = glob(dir+'*')
        if show_all:
            pathes += glob(dir+'.*')
        children_d = [p for p in pathes if os.path.isdir(p)] if not get_only_files else []
        children_f = [p for p in pathes if os.path.isfile(p)] if not get_only_directories else []
        if children_d+children_f == []:
            status = 1
            return status, [[],[]]

        # Prepare output
        children = [sorted(children_d), sorted(children_f)]
        status = 0
        return status, children

    def _read_description(self, dir):
        """
        Get .description.lsi of dir.

        Parameters
        ----------
        dir : String
            Directory Path

        Returns
        -------
        status : Int
            0 == success
            1 == description file not exists
            2 == permission denied
            3 == error
        description : String
            description string of directory.
        """
        dir = dir+'/' if dir[-1]!='/' else dir
        desc_path = dir + self.config.description_name
        try:
            with open(desc_path, 'r') as f:
                description = f.read()
            if description == '':
                description = None 
            status = 0
        except Exception as e:
            e = str(e)
            if 'no such file or directory' in e:
                description = None
                status = 1
            elif 'Permission denied' in e:
                description = ';w;Dir ' + self.config.get_color('red') + '(Permission denied)'
                status = 2 
            else:
                description = None
                status = 3

        return status, description

    def _create_item(self, path):
        """
        Create directory or file dictionary.

        Parameters
        ----------
        path : String
            directory or file path.
        
        Returns
        -------
        status : Int
            0 == path is dir
            1 == path is file
            2 == error
        item : Dict
            dict.keys(default) = ['path', 'type', 'depth']
            dict.keys(optional) = ['description', 'auth', 'children']
        """

        def get_east_asian_width_count(text):
            count = 0
            for c in text:
                if unicodedata.east_asian_width(c) in 'FWA':
                    count += 2
                else:
                    count += 1
            return count

        base_path = path.split('/')[-1]
        item = {
                'path': base_path, 
                'path_length': get_east_asian_width_count(base_path), 
                'depth': 0
                }
        if os.path.isdir(path):
            s, description = self._read_description(path)
            has_desc = True if description is not None else False
            if has_desc:
                item['description'] = description
            item['type'] = 'Dir'
            status = 0
        elif os.path.isfile(path):
            item['type'] = 'File'
            status = 1
        else:
            item = {}
            status = 2
        return status, item

    def get_items(self, dir, show_all=False, show_only_directories=False, show_only_files=False):
        """
        Repeat self._create_item() along all children of 'dir'.

        Parameters
        ----------
        dir : String
            Directory Path
        show_all : Boolean (Optional)
            Whether show hidden files or not.
        
        Return
        ------
        status : Int
            0 == success
            1 == error
        top_item : Dict
            keys : path, children_d, children_f
                path : Strin (path of top directory)
                children_d : List[items]
                children_f : List[items]
        """
        if not os.path.isdir(dir):
            print('error: cannot open directory \''+dir+'\': No such directory.')
            exit()
        if not os.access(dir, os.R_OK):
            print('error: cannot open directory \''+dir+'\': Permission denied.')
            exit()
        status, children = self._get_children(dir, show_all=show_all, get_only_directories=show_only_directories, get_only_files=show_only_files)
        children_d, children_f = children
        children_d = [self._create_item(child)[1] for child in children_d]
        children_f = [self._create_item(child)[1] for child in children_f]
        top_item = {
                'path': dir,
                'children_d': children_d,
                'children_f': children_f
                }
        return status, top_item


class LsiContentTransforms():
    def __init__(self, search_word, limit_file_num):
        """
        Content Transforms (for children).
        e.g. custom sort function, grep function.

        Parameters
        ----------
        search_word : String
            (command) -s, --search
        limit_file_num : Int
            (command) -n, --limit-file-num
        """
        # Set Config
        self.config = Config()

        # Set Auguments
        self.search_word = search_word
        self.limit_file_num = limit_file_num

    def _search(self, children, prev_status):
        """
        Search word from path and description.
        This like grep function.

        Parameters
        ----------
        children : List[children_d, children_f]
            children_d : List[items]
            children_f : List[items]
        prev_status : Int

        Returns
        -------
        status : Boolean
            0 == success
            1 == failed
        output_children : List[children_d, children_f]
            children_d : List[items]
            children_f : List[items]
        """
        search_word = self.search_word
        replace_word = self.config.tag['search'] + search_word + self.config.tag['search_end']
        tags = list(self.config.color.keys())
        tag_mapper = []
        inv_tag_mapper = []
        hash = '\\' + self.config.symbol*21
        if set(self.config.symbol)==set(search_word) or \
           search_word[-1]=='\\' or search_word[0]=='\\' or \
           '\\'+self.config.symbol in search_word or self.config.symbol+'\\' in search_word:
            status = 1
            output_children = [[], []]
            invalid_word = str(set(hash))
            print('sorry, only', invalid_word, 'is invalid search word.')
            return status, output_children

        for tag in tags:
            tag_mapper += [hash+'\\']
            inv_tag_mapper += [tag]
            hash += self.config.symbol
        output_children = [[], []]
        for item in children[0]+children[1]:
            match_path = search_word in item['path']
            if 'description' in item.keys():
                description = item['description']
                for hash, tag in zip(tag_mapper, inv_tag_mapper):
                    description = description.replace(tag, hash)
                match_desc = search_word in description
            else:
                match_desc = False
            if match_path or match_desc:
                if match_path:
                    item['path'] = item['path'].replace(search_word, replace_word)
                if match_desc:
                    description = description.replace(search_word, replace_word)
                    for hash, tag in zip(tag_mapper, inv_tag_mapper):
                        description = description.replace(hash, tag)
                    item['description'] = description
                if item['type']=='Dir':
                    output_children[0] += [item]
                elif item['type']=='File':
                    output_children[1] += [item]
            else:
                pass
        status = 0
        return status, output_children

    def _limit_file_num(self, children, condition):
        """
        Alert number of files if it exceeded limit.

        Parameters
        ----------
        children : List[children_d, children_f]
            children_d : List[items]
            children_f : List[items]
        prev_status : Int

        Returns
        -------
        status : Boolean
            0 == number of files <= limit
            1 == number of files > limit, and 'yes'
            2 == number of files < limit, and 'no'
        output_children : List[children_d, children_f]
            children_d : List[items]
            children_f : List[items]
        """
        limit_file_num = self.limit_file_num
        num = len(children[0]+children[1])
        if num<=limit_file_num:
            status = 0
            return status, children
        res = input('too many items ({}). show these? [y-n] : '.format(num))
        if res.lower() in ['y', 'yes']:
            status = 1
            return status, children
        else:
            status = 2
            return status, [[], []]

    def run(self, children, condition):
        """
        This apply content_transforms to all items.

        Parameters
        ----------
        item : Dict
        condition : Dict
        
        Returns
        -------
        status : Boolean
            0 == success
            1 == failed
        children : List[children_d, children_f]
            children_d : List[items]
            children_f : List[items]
        """
        prev_status = condition['status']
        transforms = []
        transforms += [self._search] if self.search_word!='' else []
        transforms += [self._limit_file_num] if self.limit_file_num!=0 else []
        for tr in transforms:
            prev_status, children = tr(children, prev_status)
        status = 0
        return status, children


class Lsi():
    def __init__(
            self,
            dir,
            show_all=False,
            show_only_directories=False,
            show_only_files=False,
            show_file_num=False,
            limit_file_num=50,
            search_word=''
            ):
        """
        lsi Manager.
        Set all optional command line arguments here.
        
        Parameters
        ----------
        dir : String
            Directory Path
        show_all : Boolean (Optional)
            (command) -a, --all
            True -> Show all files and directories.
        show_only_directories : Boolean (Optional)
            (command) -d, --only-directories
            True -> Do not show files.
        show_only_files : Boolean (Optional)
            (command) -f, --only-files
            True -> Do not show directories.
        show_file_num : Boolean (Optional)
            (command) -l, --show-file-num
            True -> Show number of children files.
        limit_file_num : Int (Optional)
            (command) -n, --limit-file-num
            Set confirm condition (num of children files).
        search_word : String (Optional)
            (command) -s, --search
        """
        
        # Set CommandLine Arguments
        self.dir = dir
        self.show_all = show_all
        self.show_only_files = show_only_files
        self.show_only_directories = show_only_directories
        self.limit_file_num = limit_file_num
        self.show_file_num = show_file_num
        
        # Set Lsi Modules
        self.config = Config()
        self.item_loader = LsiItemLoader()
        self.content_transforms = LsiContentTransforms(
                search_word=search_word,
                limit_file_num=limit_file_num
                )
        self.visual_transforms = LsiVisualTransforms()

    def print_items(self, top_path, children, condition):
        """
        Repeat self._visual_tr_manager() along directories and files on this level.
        Then (or while), Print these.
        
        Parameters
        ----------
        top_path : String
        children : List[children_d, children_f]
        condition : Dict

        Return
        ------
        status : Boolean
            0 == success
            1 == failed
        """
        children = children[0]+children[1]
        if len(children)>0 and top_path!='./':
            top_path = os.path.abspath(top_path)
            above_path = self.config.get_color('pwd') + '/'.join(top_path.split('/')[:-1])+'/'
            base_name = self.config.get_color('pwd_current')+top_path.split('/')[-1]+'/'
            print(above_path+base_name+self.config.get_color('end'))
        for i, item in enumerate(children):
            if i+1==len(children):
                condition['is_last'] = 1
            else:
                condition['is_last'] = 0
            s, output = self.visual_transforms.run(item, condition)
            print(output)
        status = 0
        return status

    def run(self):
        """
        Management all functions.
        """
        status, top_item = self.item_loader.get_items(
                self.dir, 
                show_all=self.show_all,
                show_only_directories=self.show_only_directories,
                show_only_files=self.show_only_files
                )
        top_path = top_item['path']
        children = [top_item['children_d'], top_item['children_f']]

        condition = {
                'status': 0,
                }
        status, children = self.content_transforms.run(
                children,
                condition
                )

        condition = {
                'status': 0
                }
        status = self.print_items(
                top_path,
                children,
                condition
                )
        
        
def main():
    # Parser setting
    parser = argparse.ArgumentParser(description="LSI - LS Improved")
    parser.add_argument('dir', type=str, nargs='?', default="./", metavar='DirectoryPath', help='Directory where you want to look. (default: current directory)')
    parser.add_argument('-a','--all', action='store_true', help='Show hidden files and directories. (default: Hidden)')
    parser.add_argument('-D','--only-directories', action='store_true', help='Do not show files.')
    parser.add_argument('-F','--only-files', action='store_true', help='Do not show directories.')
    parser.add_argument('-s','--search', default='', metavar='STRING', help='Search word inside of file names and descriptions')
    # parser.add_argument('-f','--show-file-num', action='store_true', help='show files num of directory')
    parser.add_argument('-n', '--limit-file-num', type=int, metavar='INT' ,default=0, help='set threshold for opening directory by many files')
    args = parser.parse_args()

    # Get parser arguments
    dir = args.dir
    dir = dir+'/' if dir[-1] != '/' else dir
    show_all = args.all
    show_only_directories = args.only_directories
    show_only_files = args.only_files
    # show_file_num = args.show_file_num
    limit_file_num = args.limit_file_num
    search_word = args.search

    lsi = Lsi(
            dir,
            show_all=show_all, 
            show_only_directories=show_only_directories, 
            show_only_files=show_only_files, 
            # show_file_num=show_file_num,
            limit_file_num=limit_file_num,
            search_word=search_word
            )

    lsi.run()

if __name__ == '__main__':
    main()
